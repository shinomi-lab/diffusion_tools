{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Diffusion Tools","title":"Top"},{"location":"#diffusion-tools","text":"","title":"Diffusion Tools"},{"location":"SUMMARY/","text":"Top difftools.algebra difftools.diffusion difftools.maximization difftools.trial","title":"SUMMARY"},{"location":"algebra/","text":"","title":"difftools.algebra"},{"location":"diffusion/","text":"ic_adjmat ( n , adj , S , prob_mat , seed ) Parameters n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set ( \\({0,1}^n\\) ) as 1d int64 array Let \\(V={1, ..., n}\\) and a seed set \\(S \\subseteq V\\) , the indicator of \\(S\\) is a \\(n\\) -dimentional binary vector where the \\(i\\) -th component equals 1 if \\(i \\in V\\) otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray seed : a seed value to initialize RNG unless None given Returns The tuple of: - the indicator of an activated node set - the history of active node indicators - the history of activated node indicators Source code in difftools/diffusion.py @cc . export ( \"ic_adjmat\" , \"(i8, i8[:,:], i8[:], f8[:,:], optional(i8))\" , ) @njit def ic_adjmat ( n : int , adj : np . ndarray , S : np . ndarray , prob_mat : np . ndarray , seed : Optional [ int ] ) -> Tuple [ np . ndarray , np . ndarray , np . ndarray ]: \"\"\" Parameters ---------- n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set (${0,1}^n$) as 1d int64 array Let $V={1, ..., n}$ and a seed set $S \\\\subseteq V$, the indicator of $S$ is a $n$-dimentional binary vector where the $i$-th component equals 1 if $i \\\\in V$ otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray seed : a seed value to initialize RNG unless None given Returns ------- The tuple of: - the indicator of an activated node set - the history of active node indicators - the history of activated node indicators \"\"\" I = S . astype ( np . int64 ) # active node group (currently activated) T = S . astype ( np . int64 ) # total active node group (activated) # history hist = [( I , T )] if not seed is None : nrd . seed ( seed ) while np . count_nonzero ( I ) > 0 : # make a new active group with a current one J = np . zeros ( n , np . int64 ) # init a new active group for i in range ( n ): if I [ i ] == 0 : continue # i is in a current active group for j in range ( n ): if T [ j ] == 1 : continue if J [ j ] == 1 : continue # j is not active yet if adj [ i , j ] == 0 : continue # j is a successor of i # note: a_ij = 0 if and only if an edge (i, j) does not exist in a graph if ( prob_mat [ i , j ] > nrd . random () ): # j should not be activated if p = 0, and j should be acitvated if p = 1 # activate j with a probability as prob_mat[i, j] J [ j ] = 1 # replace an active group to new one I = J . astype ( np . int64 ) # add new active nodes to the total group # note: for all j, J_j = 1 & T_j = 0, so every component of T + I (= T + J) is at most 1 T += I hist . append (( I , T )) l = len ( hist ) Is = np . zeros (( l , n ), np . int64 ) Ts = np . zeros (( l , n ), np . int64 ) for i , h in enumerate ( hist ): Is [ i ] = h [ 0 ] Ts [ i ] = h [ 1 ] return T , Is , Ts independent_cascade ( g , I0 , ep_map , gen ) Parameters g : networkx graph I0 : seed node set ep_map : propagation probability map gen : numpy random generator Returns The history of tuple of active node set and activated node set Source code in difftools/diffusion.py def independent_cascade ( g , I0 , ep_map , gen ) -> List [ Tuple [ Set [ int ], Set [ int ]]]: \"\"\" Parameters ---------- g : networkx graph I0 : seed node set ep_map : propagation probability map gen : numpy random generator Returns ------- The history of tuple of active node set and activated node set \"\"\" G = g if g . is_directed () else g . to_directed () # gen = nrd.Generator(nrd.PCG64(nrd.SeedSequence(seed))) I = I0 S = I . copy () ss = [( I , S )] while len ( I ) > 0 : J = set () for i in I : for j in G . successors ( i ): if j in S : continue if ep_map [( i , j )] > gen . random (): J . add ( j ) I = J S = S | I ss . append (( I , S )) return ss","title":"difftools.diffusion"},{"location":"diffusion/#difftools.diffusion.ic_adjmat","text":"","title":"ic_adjmat()"},{"location":"diffusion/#difftools.diffusion.ic_adjmat--parameters","text":"n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set ( \\({0,1}^n\\) ) as 1d int64 array Let \\(V={1, ..., n}\\) and a seed set \\(S \\subseteq V\\) , the indicator of \\(S\\) is a \\(n\\) -dimentional binary vector where the \\(i\\) -th component equals 1 if \\(i \\in V\\) otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray seed : a seed value to initialize RNG unless None given","title":"Parameters"},{"location":"diffusion/#difftools.diffusion.ic_adjmat--returns","text":"The tuple of: - the indicator of an activated node set - the history of active node indicators - the history of activated node indicators Source code in difftools/diffusion.py @cc . export ( \"ic_adjmat\" , \"(i8, i8[:,:], i8[:], f8[:,:], optional(i8))\" , ) @njit def ic_adjmat ( n : int , adj : np . ndarray , S : np . ndarray , prob_mat : np . ndarray , seed : Optional [ int ] ) -> Tuple [ np . ndarray , np . ndarray , np . ndarray ]: \"\"\" Parameters ---------- n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set (${0,1}^n$) as 1d int64 array Let $V={1, ..., n}$ and a seed set $S \\\\subseteq V$, the indicator of $S$ is a $n$-dimentional binary vector where the $i$-th component equals 1 if $i \\\\in V$ otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray seed : a seed value to initialize RNG unless None given Returns ------- The tuple of: - the indicator of an activated node set - the history of active node indicators - the history of activated node indicators \"\"\" I = S . astype ( np . int64 ) # active node group (currently activated) T = S . astype ( np . int64 ) # total active node group (activated) # history hist = [( I , T )] if not seed is None : nrd . seed ( seed ) while np . count_nonzero ( I ) > 0 : # make a new active group with a current one J = np . zeros ( n , np . int64 ) # init a new active group for i in range ( n ): if I [ i ] == 0 : continue # i is in a current active group for j in range ( n ): if T [ j ] == 1 : continue if J [ j ] == 1 : continue # j is not active yet if adj [ i , j ] == 0 : continue # j is a successor of i # note: a_ij = 0 if and only if an edge (i, j) does not exist in a graph if ( prob_mat [ i , j ] > nrd . random () ): # j should not be activated if p = 0, and j should be acitvated if p = 1 # activate j with a probability as prob_mat[i, j] J [ j ] = 1 # replace an active group to new one I = J . astype ( np . int64 ) # add new active nodes to the total group # note: for all j, J_j = 1 & T_j = 0, so every component of T + I (= T + J) is at most 1 T += I hist . append (( I , T )) l = len ( hist ) Is = np . zeros (( l , n ), np . int64 ) Ts = np . zeros (( l , n ), np . int64 ) for i , h in enumerate ( hist ): Is [ i ] = h [ 0 ] Ts [ i ] = h [ 1 ] return T , Is , Ts","title":"Returns"},{"location":"diffusion/#difftools.diffusion.independent_cascade","text":"","title":"independent_cascade()"},{"location":"diffusion/#difftools.diffusion.independent_cascade--parameters","text":"g : networkx graph I0 : seed node set ep_map : propagation probability map gen : numpy random generator","title":"Parameters"},{"location":"diffusion/#difftools.diffusion.independent_cascade--returns","text":"The history of tuple of active node set and activated node set Source code in difftools/diffusion.py def independent_cascade ( g , I0 , ep_map , gen ) -> List [ Tuple [ Set [ int ], Set [ int ]]]: \"\"\" Parameters ---------- g : networkx graph I0 : seed node set ep_map : propagation probability map gen : numpy random generator Returns ------- The history of tuple of active node set and activated node set \"\"\" G = g if g . is_directed () else g . to_directed () # gen = nrd.Generator(nrd.PCG64(nrd.SeedSequence(seed))) I = I0 S = I . copy () ss = [( I , S )] while len ( I ) > 0 : J = set () for i in I : for j in G . successors ( i ): if j in S : continue if ep_map [( i , j )] > gen . random (): J . add ( j ) I = J S = S | I ss . append (( I , S )) return ss","title":"Returns"},{"location":"maximization/","text":"ic_infl_prop ( seed , n , adj , S , prob_mat ) Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required S ndarray the indicator of a seed set ( \\(\\{0,1\\}^n\\) ) as 1d int64 array. Let \\(V=\\{1, ..., n\\}\\) and a seed set \\(S \\subseteq V\\) , the indicator of \\(S\\) is a \\(n\\) -dimentional binary vector where \\(i\\) -th component equals 1 if \\(i \\in V\\) otherwise 0. required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required Returns: Type Description ndarray the indicator of an activated node set Source code in difftools/maximization.py @cc . export ( \"ic_infl_prop\" , \"i8[:](optional(i8), i8, i8[:,:], i8[:], f8[:,:])\" ) @njit def ic_infl_prop ( seed : Optional [ int ], n : int , adj : np . ndarray , S : np . ndarray , prob_mat : np . ndarray ) -> np . ndarray : \"\"\" Parameters: seed : a seed value to initialize RNG unless None given n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set ($\\\\{0,1\\\\}^n$) as 1d int64 array. Let $V=\\\\{1, ..., n\\\\}$ and a seed set $S \\\\subseteq V$, the indicator of $S$ is a $n$-dimentional binary vector where $i$-th component equals 1 if $i \\\\in V$ otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray Returns: the indicator of an activated node set \"\"\" return dd . ic_adjmat ( n , adj , S , prob_mat , seed )[ 0 ] ic_infl_prop_exp ( seed , m , n , adj , S , prob_mat ) Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required S ndarray the indicator of a seed set ( \\(\\{0,1\\}^n\\) ) as 1d int64 array. Let \\(V=\\{1, ..., n\\}\\) and a seed set \\(S \\subseteq V\\) , the indicator of \\(S\\) is a \\(n\\) -dimentional binary vector where \\(i\\) -th component equals 1 if \\(i \\in V\\) otherwise 0. required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required Returns: Type Description ndarray An activation ratio distribution on \\(V\\) where \\(i\\) -th component is the average times that \\(i\\) is activated in m iterations Source code in difftools/maximization.py @cc . export ( \"ic_infl_prop_exp\" , \"(optional(i8), i8, i8, i8[:,:], i8[:], f8[:,:])\" ) @njit def ic_infl_prop_exp ( seed : Optional [ int ], m : int , n : int , adj : np . ndarray , S : np . ndarray , prob_mat : np . ndarray , ) -> np . ndarray : \"\"\" Parameters: seed : a seed value to initialize RNG unless None given m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set ($\\\\{0,1\\\\}^n$) as 1d int64 array. Let $V=\\\\{1, ..., n\\\\}$ and a seed set $S \\\\subseteq V$, the indicator of $S$ is a $n$-dimentional binary vector where $i$-th component equals 1 if $i \\\\in V$ otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray Returns: An activation ratio distribution on $V$ where $i$-th component is the average times that $i$ is activated in m iterations \"\"\" d = np . zeros ( n , np . float64 ) if not seed is None : nrd . seed ( seed ) for i in numba . prange ( m ): d += ic_infl_prop ( None , n , adj , S , prob_mat ) dist = d / m return dist ic_infl_sprd_exp ( seed , m , n , adj , S , prob_mat ) Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required S ndarray the indicator of a seed set ( \\(\\{0,1\\}^n\\) ) as 1d int64 array. Let \\(V=\\{1, ..., n\\}\\) and a seed set \\(S \\subseteq V\\) , the indicator of \\(S\\) is a \\(n\\) -dimentional binary vector where the \\(i\\) -th component equals 1 if \\(i \\in V\\) otherwise 0. required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required Returns: Type Description number The average number of activated nodes Source code in difftools/maximization.py @cc . export ( \"ic_infl_sprd\" , \"f8(optional(i8), i8, i8, i8[:,:], i8[:], f8[:,:])\" , ) @njit def ic_infl_sprd_exp ( seed : Optional [ int ], m : int , n : int , adj : np . ndarray , S : np . ndarray , prob_mat : np . ndarray , ) -> np . number : \"\"\" Parameters: seed : a seed value to initialize RNG unless None given m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set ($\\\\{0,1\\\\}^n$) as 1d int64 array. Let $V=\\\\{1, ..., n\\\\}$ and a seed set $S \\\\subseteq V$, the indicator of $S$ is a $n$-dimentional binary vector where the $i$-th component equals 1 if $i \\\\in V$ otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray Returns: The average number of activated nodes \"\"\" return ic_infl_prop_exp ( seed , m , n , adj , S , prob_mat ) . sum () ic_sw_sprd_exp ( seed , m , n , adj , S , prob_mat , util_dist ) Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required S ndarray the indicator of a seed set ( \\(\\{0,1\\}^n\\) ) as 1d int64 array. Let \\(V=\\{1, ..., n\\}\\) and a seed set \\(S \\subseteq V\\) , the indicator of \\(S\\) is a \\(n\\) -dimentional binary vector where the \\(i\\) -th component equals 1 if \\(i \\in V\\) otherwise 0. required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required util_dist ndarray an utility distribusion on the indicator of \\(V\\) as 1d float64 array required Returns: Type Description number The average of social welfare ( \\(\\mathbb{E}\\left[\\sum_{i \\in V}u_i\\right] = \\sum_{i \\in V}\\mathbb{E}\\left[u_i\\right]\\) ) Source code in difftools/maximization.py @cc . export ( \"ic_sw_sprd_exp\" , \"f8(optional(i8), i8, i8, i8[:,:], i8[:], f8[:,:], f8[:])\" , ) @njit def ic_sw_sprd_exp ( seed : Optional [ int ], m : int , n : int , adj : np . ndarray , S : np . ndarray , prob_mat : np . ndarray , util_dist : np . ndarray , ) -> np . number : \"\"\" Parameters: seed : a seed value to initialize RNG unless None given m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set ($\\\\{0,1\\\\}^n$) as 1d int64 array. Let $V=\\\\{1, ..., n\\\\}$ and a seed set $S \\\\subseteq V$, the indicator of $S$ is a $n$-dimentional binary vector where the $i$-th component equals 1 if $i \\\\in V$ otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray util_dist : an utility distribusion on the indicator of $V$ as 1d float64 array Returns: The average of social welfare ($\\\\mathbb{E}\\\\left[\\\\sum_{i \\\\in V}u_i\\\\right] = \\\\sum_{i \\\\in V}\\\\mathbb{E}\\\\left[u_i\\\\right]$) \"\"\" return ic_util_prop_exp ( seed , m , n , adj , S , prob_mat , util_dist ) . sum () ic_util_prop ( seed , n , adj , S , prob_mat , util_dist ) Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required S ndarray the indicator of a seed set ( \\(\\{0,1\\}^n\\) ) as 1d int64 array. Let \\(V=\\{1, ..., n\\}\\) and a seed set \\(S \\subseteq V\\) , the indicator of \\(S\\) is a \\(n\\) -dimentional binary vector where the \\(i\\) -th component equals 1 if \\(i \\in V\\) otherwise 0. required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required util_dist ndarray an utility distribusion on the indicator of \\(V\\) as 1d float64 array required Returns: Type Description ndarray the utility distribution on the indicator of an activated node set where \\(i\\) -th component equals the utility of \\(i\\) if \\(i\\) is activated otherwise 0 Source code in difftools/maximization.py @cc . export ( \"ic_util_prop\" , \"f8[:](optional(i8), i8, i8[:,:], i8[:], f8[:,:], f8[:])\" , ) @njit def ic_util_prop ( seed : Optional [ int ], n : int , adj : np . ndarray , S : np . ndarray , prob_mat : np . ndarray , util_dist : np . ndarray , ) -> np . ndarray : \"\"\" Parameters: seed : a seed value to initialize RNG unless None given n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set ($\\\\{0,1\\\\}^n$) as 1d int64 array. Let $V=\\\\{1, ..., n\\\\}$ and a seed set $S \\\\subseteq V$, the indicator of $S$ is a $n$-dimentional binary vector where the $i$-th component equals 1 if $i \\\\in V$ otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray util_dist : an utility distribusion on the indicator of $V$ as 1d float64 array Returns: the utility distribution on the indicator of an activated node set where $i$-th component equals the utility of $i$ if $i$ is activated otherwise 0 \"\"\" d = dd . ic_adjmat ( n , adj , S , prob_mat , seed )[ 0 ] return d * util_dist ic_util_prop_exp ( seed , m , n , adj , S , prob_mat , util_dist ) Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required S ndarray the indicator of a seed set ( \\(\\{0,1\\}^n\\) ) as 1d int64 array. Let \\(V=\\{1, ..., n\\}\\) and a seed set \\(S \\subseteq V\\) , the indicator of \\(S\\) is a \\(n\\) -dimentional binary vector where \\(i\\) -th component equals 1 if \\(i \\in V\\) otherwise 0. required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required util_dist ndarray an utility distribusion on the indicator of \\(V\\) as 1d float64 array required Returns: Type Description ndarray An average utility distribution on \\(V\\) where \\(i\\) -th component is the utility of \\(i\\) times the activation ratio (which is equal to the Hadamard product of the utilty distribution and an activation ratio ditribution) Source code in difftools/maximization.py @cc . export ( \"ic_util_prop_exp\" , \"f8[:](optional(i8), i8, i8, i8[:,:], i8[:], f8[:,:], f8[:])\" , ) @njit def ic_util_prop_exp ( seed : Optional [ int ], m : int , n : int , adj : np . ndarray , S : np . ndarray , prob_mat : np . ndarray , util_dist : np . ndarray , ) -> np . ndarray : \"\"\" Parameters: seed : a seed value to initialize RNG unless None given m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set ($\\\\{0,1\\\\}^n$) as 1d int64 array. Let $V=\\\\{1, ..., n\\\\}$ and a seed set $S \\\\subseteq V$, the indicator of $S$ is a $n$-dimentional binary vector where $i$-th component equals 1 if $i \\\\in V$ otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray util_dist : an utility distribusion on the indicator of $V$ as 1d float64 array Returns: An average utility distribution on $V$ where $i$-th component is the utility of $i$ times the activation ratio (which is equal to the Hadamard product of the utilty distribution and an activation ratio ditribution) \"\"\" return ic_infl_prop_exp ( seed , m , n , adj , S , prob_mat ) * util_dist im_greedy ( seed , k , m , n , adj , prob_mat ) Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required k int the maximum size of seed node sets required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required Returns: Type Description Tuple[numpy.ndarray, numpy.ndarray] The tuple of: an IM near optimal seed set the \\(k\\) -length list of 1d \\(n\\) -length vectors where the \\(i\\) -th component of the \\(j\\) -th vector element is the influence average of a seed set \\(S_j \\cup \\{i\\}\\) where \\(S_j\\) is a near optimal \\(j\\) -size set Source code in difftools/maximization.py @cc . export ( \"im_greedy\" , \"(optional(i8), i8, i8, i8, i8[:,:], f8[:,:])\" ) @njit def im_greedy ( seed : Optional [ int ], k : int , m : int , n : int , adj : np . ndarray , prob_mat : np . ndarray ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Parameters: seed : a seed value to initialize RNG unless None given k : the maximum size of seed node sets m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray Returns: The tuple of: - an IM near optimal seed set - the $k$-length list of 1d $n$-length vectors where the $i$-th component of the $j$-th vector element is the influence average of a seed set $S_j \\\\cup \\\\{i\\\\}$ where $S_j$ is a near optimal $j$-size set \"\"\" V = np . repeat ( 1 , n ) S = np . zeros ( n , dtype = np . int64 ) hist = np . zeros (( k , n ), dtype = np . float64 ) for j in range ( k ): s_dist = np . zeros ( n ) W = V - S for i in range ( n ): if W [ i ] != 0 : Su = S . copy () Su [ i ] = 1 s_dist [ i ] = ic_infl_sprd_exp ( seed , m , n , adj , Su , prob_mat ) S [ s_dist . argmax ()] = 1 hist [ j ] = s_dist return S , hist swm_greedy ( seed , k , m , n , adj , prob_mat , util_dist ) Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required k int the maximum size of seed node sets required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required util_dist ndarray an utility distribusion on the indicator of \\(V\\) as 1d float64 array required Returns: Type Description Tuple[numpy.ndarray, numpy.ndarray] The tuple of: the indicator of an SWM near optimal seed set the \\(k\\) -length list of 1d \\(n\\) -length vectors where the \\(i\\) -th component of the \\(j\\) -th vector element is the social welfare average of a seed set \\(S_j \\cup \\{i\\}\\) where \\(S_j\\) is a near optimal \\(j\\) -size set Source code in difftools/maximization.py @cc . export ( \"swm_greedy\" , \"(optional(i8), i8, i8, i8, i8[:,:], f8[:,:], f8[:])\" , ) @njit def swm_greedy ( seed : Optional [ int ], k : int , m : int , n : int , adj : np . ndarray , prob_mat : np . ndarray , util_dist : np . ndarray , ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Parameters: seed : a seed value to initialize RNG unless None given k : the maximum size of seed node sets m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray util_dist : an utility distribusion on the indicator of $V$ as 1d float64 array Returns: The tuple of: - the indicator of an SWM near optimal seed set - the $k$-length list of 1d $n$-length vectors where the $i$-th component of the $j$-th vector element is the social welfare average of a seed set $S_j \\\\cup \\\\{i\\\\}$ where $S_j$ is a near optimal $j$-size set \"\"\" V = np . repeat ( 1 , n ) S = np . zeros ( n , dtype = np . int64 ) hist = np . zeros (( k , n ), dtype = np . float64 ) for j in range ( k ): s_dist = np . zeros ( n ) W = V - S for i in range ( n ): if W [ i ] != 0 : Su = S . copy () Su [ i ] = 1 s_dist [ i ] = ic_sw_sprd_exp ( seed , m , n , adj , Su , prob_mat , util_dist ) S [ s_dist . argmax ()] = 1 hist [ j ] = s_dist return S , hist","title":"difftools.maximization"},{"location":"maximization/#difftools.maximization.ic_infl_prop","text":"Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required S ndarray the indicator of a seed set ( \\(\\{0,1\\}^n\\) ) as 1d int64 array. Let \\(V=\\{1, ..., n\\}\\) and a seed set \\(S \\subseteq V\\) , the indicator of \\(S\\) is a \\(n\\) -dimentional binary vector where \\(i\\) -th component equals 1 if \\(i \\in V\\) otherwise 0. required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required Returns: Type Description ndarray the indicator of an activated node set Source code in difftools/maximization.py @cc . export ( \"ic_infl_prop\" , \"i8[:](optional(i8), i8, i8[:,:], i8[:], f8[:,:])\" ) @njit def ic_infl_prop ( seed : Optional [ int ], n : int , adj : np . ndarray , S : np . ndarray , prob_mat : np . ndarray ) -> np . ndarray : \"\"\" Parameters: seed : a seed value to initialize RNG unless None given n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set ($\\\\{0,1\\\\}^n$) as 1d int64 array. Let $V=\\\\{1, ..., n\\\\}$ and a seed set $S \\\\subseteq V$, the indicator of $S$ is a $n$-dimentional binary vector where $i$-th component equals 1 if $i \\\\in V$ otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray Returns: the indicator of an activated node set \"\"\" return dd . ic_adjmat ( n , adj , S , prob_mat , seed )[ 0 ]","title":"ic_infl_prop()"},{"location":"maximization/#difftools.maximization.ic_infl_prop_exp","text":"Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required S ndarray the indicator of a seed set ( \\(\\{0,1\\}^n\\) ) as 1d int64 array. Let \\(V=\\{1, ..., n\\}\\) and a seed set \\(S \\subseteq V\\) , the indicator of \\(S\\) is a \\(n\\) -dimentional binary vector where \\(i\\) -th component equals 1 if \\(i \\in V\\) otherwise 0. required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required Returns: Type Description ndarray An activation ratio distribution on \\(V\\) where \\(i\\) -th component is the average times that \\(i\\) is activated in m iterations Source code in difftools/maximization.py @cc . export ( \"ic_infl_prop_exp\" , \"(optional(i8), i8, i8, i8[:,:], i8[:], f8[:,:])\" ) @njit def ic_infl_prop_exp ( seed : Optional [ int ], m : int , n : int , adj : np . ndarray , S : np . ndarray , prob_mat : np . ndarray , ) -> np . ndarray : \"\"\" Parameters: seed : a seed value to initialize RNG unless None given m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set ($\\\\{0,1\\\\}^n$) as 1d int64 array. Let $V=\\\\{1, ..., n\\\\}$ and a seed set $S \\\\subseteq V$, the indicator of $S$ is a $n$-dimentional binary vector where $i$-th component equals 1 if $i \\\\in V$ otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray Returns: An activation ratio distribution on $V$ where $i$-th component is the average times that $i$ is activated in m iterations \"\"\" d = np . zeros ( n , np . float64 ) if not seed is None : nrd . seed ( seed ) for i in numba . prange ( m ): d += ic_infl_prop ( None , n , adj , S , prob_mat ) dist = d / m return dist","title":"ic_infl_prop_exp()"},{"location":"maximization/#difftools.maximization.ic_infl_sprd_exp","text":"Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required S ndarray the indicator of a seed set ( \\(\\{0,1\\}^n\\) ) as 1d int64 array. Let \\(V=\\{1, ..., n\\}\\) and a seed set \\(S \\subseteq V\\) , the indicator of \\(S\\) is a \\(n\\) -dimentional binary vector where the \\(i\\) -th component equals 1 if \\(i \\in V\\) otherwise 0. required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required Returns: Type Description number The average number of activated nodes Source code in difftools/maximization.py @cc . export ( \"ic_infl_sprd\" , \"f8(optional(i8), i8, i8, i8[:,:], i8[:], f8[:,:])\" , ) @njit def ic_infl_sprd_exp ( seed : Optional [ int ], m : int , n : int , adj : np . ndarray , S : np . ndarray , prob_mat : np . ndarray , ) -> np . number : \"\"\" Parameters: seed : a seed value to initialize RNG unless None given m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set ($\\\\{0,1\\\\}^n$) as 1d int64 array. Let $V=\\\\{1, ..., n\\\\}$ and a seed set $S \\\\subseteq V$, the indicator of $S$ is a $n$-dimentional binary vector where the $i$-th component equals 1 if $i \\\\in V$ otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray Returns: The average number of activated nodes \"\"\" return ic_infl_prop_exp ( seed , m , n , adj , S , prob_mat ) . sum ()","title":"ic_infl_sprd_exp()"},{"location":"maximization/#difftools.maximization.ic_sw_sprd_exp","text":"Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required S ndarray the indicator of a seed set ( \\(\\{0,1\\}^n\\) ) as 1d int64 array. Let \\(V=\\{1, ..., n\\}\\) and a seed set \\(S \\subseteq V\\) , the indicator of \\(S\\) is a \\(n\\) -dimentional binary vector where the \\(i\\) -th component equals 1 if \\(i \\in V\\) otherwise 0. required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required util_dist ndarray an utility distribusion on the indicator of \\(V\\) as 1d float64 array required Returns: Type Description number The average of social welfare ( \\(\\mathbb{E}\\left[\\sum_{i \\in V}u_i\\right] = \\sum_{i \\in V}\\mathbb{E}\\left[u_i\\right]\\) ) Source code in difftools/maximization.py @cc . export ( \"ic_sw_sprd_exp\" , \"f8(optional(i8), i8, i8, i8[:,:], i8[:], f8[:,:], f8[:])\" , ) @njit def ic_sw_sprd_exp ( seed : Optional [ int ], m : int , n : int , adj : np . ndarray , S : np . ndarray , prob_mat : np . ndarray , util_dist : np . ndarray , ) -> np . number : \"\"\" Parameters: seed : a seed value to initialize RNG unless None given m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set ($\\\\{0,1\\\\}^n$) as 1d int64 array. Let $V=\\\\{1, ..., n\\\\}$ and a seed set $S \\\\subseteq V$, the indicator of $S$ is a $n$-dimentional binary vector where the $i$-th component equals 1 if $i \\\\in V$ otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray util_dist : an utility distribusion on the indicator of $V$ as 1d float64 array Returns: The average of social welfare ($\\\\mathbb{E}\\\\left[\\\\sum_{i \\\\in V}u_i\\\\right] = \\\\sum_{i \\\\in V}\\\\mathbb{E}\\\\left[u_i\\\\right]$) \"\"\" return ic_util_prop_exp ( seed , m , n , adj , S , prob_mat , util_dist ) . sum ()","title":"ic_sw_sprd_exp()"},{"location":"maximization/#difftools.maximization.ic_util_prop","text":"Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required S ndarray the indicator of a seed set ( \\(\\{0,1\\}^n\\) ) as 1d int64 array. Let \\(V=\\{1, ..., n\\}\\) and a seed set \\(S \\subseteq V\\) , the indicator of \\(S\\) is a \\(n\\) -dimentional binary vector where the \\(i\\) -th component equals 1 if \\(i \\in V\\) otherwise 0. required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required util_dist ndarray an utility distribusion on the indicator of \\(V\\) as 1d float64 array required Returns: Type Description ndarray the utility distribution on the indicator of an activated node set where \\(i\\) -th component equals the utility of \\(i\\) if \\(i\\) is activated otherwise 0 Source code in difftools/maximization.py @cc . export ( \"ic_util_prop\" , \"f8[:](optional(i8), i8, i8[:,:], i8[:], f8[:,:], f8[:])\" , ) @njit def ic_util_prop ( seed : Optional [ int ], n : int , adj : np . ndarray , S : np . ndarray , prob_mat : np . ndarray , util_dist : np . ndarray , ) -> np . ndarray : \"\"\" Parameters: seed : a seed value to initialize RNG unless None given n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set ($\\\\{0,1\\\\}^n$) as 1d int64 array. Let $V=\\\\{1, ..., n\\\\}$ and a seed set $S \\\\subseteq V$, the indicator of $S$ is a $n$-dimentional binary vector where the $i$-th component equals 1 if $i \\\\in V$ otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray util_dist : an utility distribusion on the indicator of $V$ as 1d float64 array Returns: the utility distribution on the indicator of an activated node set where $i$-th component equals the utility of $i$ if $i$ is activated otherwise 0 \"\"\" d = dd . ic_adjmat ( n , adj , S , prob_mat , seed )[ 0 ] return d * util_dist","title":"ic_util_prop()"},{"location":"maximization/#difftools.maximization.ic_util_prop_exp","text":"Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required S ndarray the indicator of a seed set ( \\(\\{0,1\\}^n\\) ) as 1d int64 array. Let \\(V=\\{1, ..., n\\}\\) and a seed set \\(S \\subseteq V\\) , the indicator of \\(S\\) is a \\(n\\) -dimentional binary vector where \\(i\\) -th component equals 1 if \\(i \\in V\\) otherwise 0. required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required util_dist ndarray an utility distribusion on the indicator of \\(V\\) as 1d float64 array required Returns: Type Description ndarray An average utility distribution on \\(V\\) where \\(i\\) -th component is the utility of \\(i\\) times the activation ratio (which is equal to the Hadamard product of the utilty distribution and an activation ratio ditribution) Source code in difftools/maximization.py @cc . export ( \"ic_util_prop_exp\" , \"f8[:](optional(i8), i8, i8, i8[:,:], i8[:], f8[:,:], f8[:])\" , ) @njit def ic_util_prop_exp ( seed : Optional [ int ], m : int , n : int , adj : np . ndarray , S : np . ndarray , prob_mat : np . ndarray , util_dist : np . ndarray , ) -> np . ndarray : \"\"\" Parameters: seed : a seed value to initialize RNG unless None given m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray S : the indicator of a seed set ($\\\\{0,1\\\\}^n$) as 1d int64 array. Let $V=\\\\{1, ..., n\\\\}$ and a seed set $S \\\\subseteq V$, the indicator of $S$ is a $n$-dimentional binary vector where $i$-th component equals 1 if $i \\\\in V$ otherwise 0. prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray util_dist : an utility distribusion on the indicator of $V$ as 1d float64 array Returns: An average utility distribution on $V$ where $i$-th component is the utility of $i$ times the activation ratio (which is equal to the Hadamard product of the utilty distribution and an activation ratio ditribution) \"\"\" return ic_infl_prop_exp ( seed , m , n , adj , S , prob_mat ) * util_dist","title":"ic_util_prop_exp()"},{"location":"maximization/#difftools.maximization.im_greedy","text":"Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required k int the maximum size of seed node sets required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required Returns: Type Description Tuple[numpy.ndarray, numpy.ndarray] The tuple of: an IM near optimal seed set the \\(k\\) -length list of 1d \\(n\\) -length vectors where the \\(i\\) -th component of the \\(j\\) -th vector element is the influence average of a seed set \\(S_j \\cup \\{i\\}\\) where \\(S_j\\) is a near optimal \\(j\\) -size set Source code in difftools/maximization.py @cc . export ( \"im_greedy\" , \"(optional(i8), i8, i8, i8, i8[:,:], f8[:,:])\" ) @njit def im_greedy ( seed : Optional [ int ], k : int , m : int , n : int , adj : np . ndarray , prob_mat : np . ndarray ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Parameters: seed : a seed value to initialize RNG unless None given k : the maximum size of seed node sets m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray Returns: The tuple of: - an IM near optimal seed set - the $k$-length list of 1d $n$-length vectors where the $i$-th component of the $j$-th vector element is the influence average of a seed set $S_j \\\\cup \\\\{i\\\\}$ where $S_j$ is a near optimal $j$-size set \"\"\" V = np . repeat ( 1 , n ) S = np . zeros ( n , dtype = np . int64 ) hist = np . zeros (( k , n ), dtype = np . float64 ) for j in range ( k ): s_dist = np . zeros ( n ) W = V - S for i in range ( n ): if W [ i ] != 0 : Su = S . copy () Su [ i ] = 1 s_dist [ i ] = ic_infl_sprd_exp ( seed , m , n , adj , Su , prob_mat ) S [ s_dist . argmax ()] = 1 hist [ j ] = s_dist return S , hist","title":"im_greedy()"},{"location":"maximization/#difftools.maximization.swm_greedy","text":"Parameters: Name Type Description Default seed Optional[int] a seed value to initialize RNG unless None given required k int the maximum size of seed node sets required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required util_dist ndarray an utility distribusion on the indicator of \\(V\\) as 1d float64 array required Returns: Type Description Tuple[numpy.ndarray, numpy.ndarray] The tuple of: the indicator of an SWM near optimal seed set the \\(k\\) -length list of 1d \\(n\\) -length vectors where the \\(i\\) -th component of the \\(j\\) -th vector element is the social welfare average of a seed set \\(S_j \\cup \\{i\\}\\) where \\(S_j\\) is a near optimal \\(j\\) -size set Source code in difftools/maximization.py @cc . export ( \"swm_greedy\" , \"(optional(i8), i8, i8, i8, i8[:,:], f8[:,:], f8[:])\" , ) @njit def swm_greedy ( seed : Optional [ int ], k : int , m : int , n : int , adj : np . ndarray , prob_mat : np . ndarray , util_dist : np . ndarray , ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Parameters: seed : a seed value to initialize RNG unless None given k : the maximum size of seed node sets m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray util_dist : an utility distribusion on the indicator of $V$ as 1d float64 array Returns: The tuple of: - the indicator of an SWM near optimal seed set - the $k$-length list of 1d $n$-length vectors where the $i$-th component of the $j$-th vector element is the social welfare average of a seed set $S_j \\\\cup \\\\{i\\\\}$ where $S_j$ is a near optimal $j$-size set \"\"\" V = np . repeat ( 1 , n ) S = np . zeros ( n , dtype = np . int64 ) hist = np . zeros (( k , n ), dtype = np . float64 ) for j in range ( k ): s_dist = np . zeros ( n ) W = V - S for i in range ( n ): if W [ i ] != 0 : Su = S . copy () Su [ i ] = 1 s_dist [ i ] = ic_sw_sprd_exp ( seed , m , n , adj , Su , prob_mat , util_dist ) S [ s_dist . argmax ()] = 1 hist [ j ] = s_dist return S , hist","title":"swm_greedy()"},{"location":"trial/","text":"trial ( l , k , m , n , adj , prob_mat ) Parameters: Name Type Description Default l int the number of utility distribution samples required k int the maximum size of seed node sets required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required Returns: Type Description Dict[str, numpy.ndarray] The dictionary as: - sw-ims : a list of the social welfare by an IM near opt seed set under the IC model - sw-opts : a list of the opt-maximal social welfare for each utility distribution samples - im-seed : an opt-seed by influence maximization - im-hist : a history of influence maximization - swm-seeds : an indicator list of SWM near optimal seed sets - swm-hists : a list of a history of SWM - utils : \\(l\\) -size uniform samples of utility distribusions on the indicator of \\(V\\) as 1d float64 array Source code in difftools/trial.py def trial ( l : int , k : int , m : int , n : int , adj : np . ndarray , prob_mat : np . ndarray , ) -> Dict [ str , np . ndarray ]: \"\"\" Parameters: l : the number of utility distribution samples k : the maximum size of seed node sets m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray Returns: The dictionary as: - `sw-ims`: a list of the social welfare by an IM near opt seed set under the IC model - `sw-opts`: a list of the opt-maximal social welfare for each utility distribution samples - `im-seed`: an opt-seed by influence maximization - `im-hist`: a history of influence maximization - `swm-seeds`: an indicator list of SWM near optimal seed sets - `swm-hists`: a list of a history of SWM - `utils` : $l$-size uniform samples of utility distribusions on the indicator of $V$ as 1d float64 array \"\"\" util_dists = np . zeros (( l , n ), dtype = np . float64 ) for i in range ( l ): util_dists [ i ] = da . random_simplex ( None , n ) ret = trial_with_sample ( k , m , n , adj , prob_mat , util_dists ) ret [ \"utils\" ] = util_dists return ret trial_with_sample ( k , m , n , adj , prob_mat , util_dists ) Parameters: Name Type Description Default k int the maximum size of seed node sets required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required util_dists ndarray utility distribusion samples on the indicator of \\(V\\) as 1d float64 array required Returns: Type Description Dict[str, numpy.ndarray] The dictionary as: - sw-ims : a list of the social welfare by an IM opt seed set under the IC model - sw-opts : a list of the near maximums of social welfare for each utility distribution samples - im-seed : an opt-seed by influence maximization - im-hist : a history of influence maximization - swm-seeds : an opt-seed list by utility maximization - swm-hists : a list of a history of utility maximization Source code in difftools/trial.py def trial_with_sample ( k : int , m : int , n : int , adj : np . ndarray , prob_mat : np . ndarray , util_dists : np . ndarray , ) -> Dict [ str , np . ndarray ]: \"\"\" Parameters: k : the maximum size of seed node sets m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray util_dists : utility distribusion samples on the indicator of $V$ as 1d float64 array Returns: The dictionary as: - `sw-ims`: a list of the social welfare by an IM opt seed set under the IC model - `sw-opts`: a list of the near maximums of social welfare for each utility distribution samples - `im-seed`: an opt-seed by influence maximization - `im-hist`: a history of influence maximization - `swm-seeds`: an opt-seed list by utility maximization - `swm-hists`: a list of a history of utility maximization \"\"\" # l = len(util_dists) # Ts = np.zeros((l, n), dtype=np.int64) # um_hists = np.zeros((l, k, n)) # total_utils = np.zeros(l) # max_utils = np.zeros(l) S , im_hist = dm . im_greedy ( None , k , m , n , adj , prob_mat ) ret = Parallel ( n_jobs =- 1 )( delayed ( __f )( util_dist , k , m , n , adj , prob_mat , S ) for util_dist in util_dists ) ret = list ( zip ( * ret )) return { \"sw-ims\" : np . stack ( ret [ 2 ]), \"sw-opts\" : np . stack ( ret [ 3 ]), \"im-seed\" : S , \"im-hist\" : im_hist , \"swm-seeds\" : np . stack ( ret [ 0 ]), \"swm-hists\" : np . stack ( ret [ 1 ]), }","title":"difftools.trial"},{"location":"trial/#difftools.trial.trial","text":"Parameters: Name Type Description Default l int the number of utility distribution samples required k int the maximum size of seed node sets required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required Returns: Type Description Dict[str, numpy.ndarray] The dictionary as: - sw-ims : a list of the social welfare by an IM near opt seed set under the IC model - sw-opts : a list of the opt-maximal social welfare for each utility distribution samples - im-seed : an opt-seed by influence maximization - im-hist : a history of influence maximization - swm-seeds : an indicator list of SWM near optimal seed sets - swm-hists : a list of a history of SWM - utils : \\(l\\) -size uniform samples of utility distribusions on the indicator of \\(V\\) as 1d float64 array Source code in difftools/trial.py def trial ( l : int , k : int , m : int , n : int , adj : np . ndarray , prob_mat : np . ndarray , ) -> Dict [ str , np . ndarray ]: \"\"\" Parameters: l : the number of utility distribution samples k : the maximum size of seed node sets m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray Returns: The dictionary as: - `sw-ims`: a list of the social welfare by an IM near opt seed set under the IC model - `sw-opts`: a list of the opt-maximal social welfare for each utility distribution samples - `im-seed`: an opt-seed by influence maximization - `im-hist`: a history of influence maximization - `swm-seeds`: an indicator list of SWM near optimal seed sets - `swm-hists`: a list of a history of SWM - `utils` : $l$-size uniform samples of utility distribusions on the indicator of $V$ as 1d float64 array \"\"\" util_dists = np . zeros (( l , n ), dtype = np . float64 ) for i in range ( l ): util_dists [ i ] = da . random_simplex ( None , n ) ret = trial_with_sample ( k , m , n , adj , prob_mat , util_dists ) ret [ \"utils\" ] = util_dists return ret","title":"trial()"},{"location":"trial/#difftools.trial.trial_with_sample","text":"Parameters: Name Type Description Default k int the maximum size of seed node sets required m int an iteration number of the IC model required n int the number of nodes required adj ndarray the adjacency matrix of a graph as 2d int64 ndarray required prob_mat ndarray propagation probabilities on the adjacency matrix as 2d float64 ndarray required util_dists ndarray utility distribusion samples on the indicator of \\(V\\) as 1d float64 array required Returns: Type Description Dict[str, numpy.ndarray] The dictionary as: - sw-ims : a list of the social welfare by an IM opt seed set under the IC model - sw-opts : a list of the near maximums of social welfare for each utility distribution samples - im-seed : an opt-seed by influence maximization - im-hist : a history of influence maximization - swm-seeds : an opt-seed list by utility maximization - swm-hists : a list of a history of utility maximization Source code in difftools/trial.py def trial_with_sample ( k : int , m : int , n : int , adj : np . ndarray , prob_mat : np . ndarray , util_dists : np . ndarray , ) -> Dict [ str , np . ndarray ]: \"\"\" Parameters: k : the maximum size of seed node sets m : an iteration number of the IC model n : the number of nodes adj : the adjacency matrix of a graph as 2d int64 ndarray prob_mat : propagation probabilities on the adjacency matrix as 2d float64 ndarray util_dists : utility distribusion samples on the indicator of $V$ as 1d float64 array Returns: The dictionary as: - `sw-ims`: a list of the social welfare by an IM opt seed set under the IC model - `sw-opts`: a list of the near maximums of social welfare for each utility distribution samples - `im-seed`: an opt-seed by influence maximization - `im-hist`: a history of influence maximization - `swm-seeds`: an opt-seed list by utility maximization - `swm-hists`: a list of a history of utility maximization \"\"\" # l = len(util_dists) # Ts = np.zeros((l, n), dtype=np.int64) # um_hists = np.zeros((l, k, n)) # total_utils = np.zeros(l) # max_utils = np.zeros(l) S , im_hist = dm . im_greedy ( None , k , m , n , adj , prob_mat ) ret = Parallel ( n_jobs =- 1 )( delayed ( __f )( util_dist , k , m , n , adj , prob_mat , S ) for util_dist in util_dists ) ret = list ( zip ( * ret )) return { \"sw-ims\" : np . stack ( ret [ 2 ]), \"sw-opts\" : np . stack ( ret [ 3 ]), \"im-seed\" : S , \"im-hist\" : im_hist , \"swm-seeds\" : np . stack ( ret [ 0 ]), \"swm-hists\" : np . stack ( ret [ 1 ]), }","title":"trial_with_sample()"}]}